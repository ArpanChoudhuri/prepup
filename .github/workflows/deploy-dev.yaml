name: deploy-dev

on:
  push:
    branches: [ "main" ]
    paths: [ "api/**", "web/**", "k8s/**", ".github/workflows/deploy-dev.yaml" ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    env:
      REGISTRY: ghcr.io
      IMAGE_API: ghcr.io/${{ toLower(github.repository_owner) }}/prepup-api
      IMAGE_WEB: ghcr.io/${{ toLower(github.repository_owner) }}/prepup-web
      KUBE_NAMESPACE: prepup

    steps:
      - uses: actions/checkout@v4

      - name: Set up QEMU (optional for cross-platform)
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx (optional)
        uses: docker/setup-buildx-action@v2

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & push API
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./api/Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_API }}:latest
            ${{ env.IMAGE_API }}:${{ github.sha }}

      - name: Build & push Web
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./web/Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_WEB }}:latest
            ${{ env.IMAGE_WEB }}:${{ github.sha }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Write kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${KUBECONFIG_B64}" | base64 -d > $HOME/.kube/config
        env:
          KUBECONFIG_B64: ${{ secrets.KUBECONFIG_B64 }}

      - name: Create image pull secret in cluster (for GHCR)
        run: |
          # create namespace first (safe if already exists)
          kubectl apply -f k8s/00-namespace-and-config.yaml
          # create or replace docker-registry secret using a PAT stored in secrets.GHCR_PAT
          kubectl create secret docker-registry ghcr-pull-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GHCR_PAT }} \
            --namespace=$KUBE_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
          # patch the default service account in the namespace to use the imagePullSecret
          kubectl patch serviceaccount default -n $KUBE_NAMESPACE -p "{\"imagePullSecrets\": [{\"name\": \"ghcr-pull-secret\"}]}" || true
        env:
          KUBE_NAMESPACE: ${{ env.KUBE_NAMESPACE }}

      - name: Apply manifests (set images using kubectl)
        run: |
          # ensure namespace/config is applied
          kubectl apply -f k8s/00-namespace-and-config.yaml
          # apply configmaps/secrets that don't reference images
          kubectl apply -f k8s/10-api.yaml
          kubectl apply -f k8s/20-web.yaml
          # set images explicitly (avoid sed)
          kubectl -n $KUBE_NAMESPACE set image deployment/api api=${IMAGE_API}:latest
          kubectl -n $KUBE_NAMESPACE set image deployment/web web=${IMAGE_WEB}:latest
          kubectl apply -f k8s/90-ingress.yaml
        env:
          IMAGE_API: ${{ env.IMAGE_API }}
          IMAGE_WEB: ${{ env.IMAGE_WEB }}
          KUBE_NAMESPACE: ${{ env.KUBE_NAMESPACE }}

      - name: Rollout status
        run: |
          kubectl -n $KUBE_NAMESPACE rollout status deploy/api --timeout=180s
          kubectl -n $KUBE_NAMESPACE rollout status deploy/web --timeout=180s
        env:
          KUBE_NAMESPACE: ${{ env.KUBE_NAMESPACE }}
